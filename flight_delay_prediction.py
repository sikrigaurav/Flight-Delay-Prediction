# -*- coding: utf-8 -*-
"""flight_delay_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16wcOgdhbm40Or0njlt57dNMdCuYY2iWa
"""

import numpy as np
import pandas as pd
import sklearn as sck
import datetime
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
# Using Skicit-learn to split data into training and testing sets
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score

data = pd.read_csv("../flights.csv")

required_data_1 = data[data['MONTH']==1]

data.shape

#data wrangling for cancellation analysis
cancelled_flights = required_data_1[required_data_1.CANCELLED==1]
airline_cancel = cancelled_flights.groupby(["DAY"])["YEAR"].count()
#cancelled_flights
airline_cancel[15:]

#Departure delay grouped by airline
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
#plt.subplot(1,2,1)
plt.plot(airline_cancel, color="red")
plt.xlabel("Airline")
plt.ylabel("Number of cancellations")
figure(num=None, figsize=(20, 15), dpi=100, facecolor='w', edgecolor='k',)

airport_cancel_arr = cancelled_flights.groupby(["ORIGIN_AIRPORT"])["CANCELLED"].count().sort_values().tail(10)
airport_cancel_arr

airport_cancel_dep = cancelled_flights.groupby(["DESTINATION_AIRPORT"])["CANCELLED"].count().sort_values().tail(10)
airport_cancel_dep

#get the cancellation airports - origin as well as departure
airport_cancel_tot = cancelled_flights.groupby(["ORIGIN_AIRPORT", "DESTINATION_AIRPORT"])["CANCELLED"].count().sort_values().tail(5)
airport_cancel_tot

#Departure and arrival delay grouped by airline
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
#plt.subplot(1,2,1)
plt1 = plt.plot(airport_cancel_arr, 'o', color="red")
plt2 = plt.plot(airport_cancel_dep, 'o', color = "blue")
plt.xlabel("Airport")
plt.ylabel("Number of cancellations")
plt.legend((plt1, plt2), labels = ("Arrival cancellations", "Destination cancellations"),
           loc='upper left')

plt.show()

required_data['DATE'] = pd.to_datetime(required_data[['DAY', 'MONTH', 'YEAR']])

#_________________________________________________________
# Function that convert the 'HHMM' string to datetime.time
def format_time(chaine):
    if pd.isnull(chaine):
        return np.nan
    else:
        if chaine == 2400: chaine = 0
        chaine = "{0:04d}".format(int(chaine))
        heure = datetime.time(int(chaine[0:2]), int(chaine[2:4]))
        return heure
# _____________________________________________________________________
# Function that combines a date and time to produce a datetime.datetime
# def combine_date_time(x):
#     if pd.isnull(x[0]) or pd.isnull(x[1]):
#         return np.nan
#     else:
#         return datetime.datetime.combine(x[0],x[1])
    
# Combine 2 columns - Date and time
def create_flight_time(frame, col):    
    combined = []
    for index, cols in frame[['DATE', col]].iterrows():    
        if pd.isnull(cols[1]):
            combined.append(np.nan)
        elif float(cols[1]) == 2400:
            cols[0] += datetime.timedelta(days=1)
            cols[1] = datetime.time(0,0)
            if pd.isnull(cols[0]) or pd.isnull(cols[1]):
                combined.append(np.nan)
            else:
                combined.append(datetime.datetime.combine(cols[0], cols[1]))    
        else:
            cols[1] = format_time(cols[1])
            if pd.isnull(cols[0]) or pd.isnull(cols[1]):
                combined.append(np.nan)
            else:
                combined.append(datetime.datetime.combine(cols[0], cols[1])) 
    return pd.Series(combined)

required_data['SCHEDULED_DEPARTURE'] = create_flight_time(required_data, 'SCHEDULED_DEPARTURE')
required_data['DEPARTURE_TIME'] = required_data['DEPARTURE_TIME'].apply(format_time)
required_data['SCHEDULED_ARRIVAL'] = required_data['SCHEDULED_ARRIVAL'].apply(format_time)
required_data['ARRIVAL_TIME'] = required_data['ARRIVAL_TIME'].apply(format_time)

required_data.loc[:5, ['SCHEDULED_DEPARTURE', 'SCHEDULED_ARRIVAL', 'DEPARTURE_TIME',
             'ARRIVAL_TIME', 'DEPARTURE_DELAY', 'ARRIVAL_DELAY']]

invalid_columns = ['YEAR', 'MONTH', 'DAY', 'FLIGHT_NUMBER', 'DAY_OF_WEEK', 'TAIL_NUMBER', 'TAXI_OUT', 'WHEELS_OFF', 'AIR_TIME', 'DISTANCE', 'WHEELS_ON',
                  'TAXI_IN', 'DIVERTED', 'CANCELLED', 'CANCELLATION_REASON', 'AIR_SYSTEM_DELAY', 'SECURITY_DELAY', 'AIRLINE_DELAY',
                  'LATE_AIRCRAFT_DELAY', 'WEATHER_DELAY', 'DATE']

required_data = required_data.drop(invalid_columns, axis=1)

#drop missing data
required_data.dropna(inplace = True)
required_data

AS = required_data.loc[required_data['AIRLINE'] == 'AS',:]
np.average(AS['DEPARTURE_DELAY'])

airline_avg_delay_dep = required_data.groupby(["AIRLINE"])["DEPARTURE_DELAY"].mean()
airline_avg_delay_dep

airline_avg_delay_arr = required_data.groupby(["AIRLINE"])["ARRIVAL_DELAY"].mean()
airline_avg_delay_arr

pd.concat([airline_avg_delay_dep, airline_avg_delay_arr], axis = 1)

#Departure delay grouped by airline
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
#plt.subplot(1,2,1)
plt.plot(airline_avg_delay_dep,'x', color="red")
plt.xlabel("Airline")
plt.ylabel("Average delay")
figure(num=None, figsize=(20, 15), dpi=100, facecolor='w', edgecolor='k',)

# #Departure and arrival delay grouped by airline
# figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
# #plt.subplot(1,2,1)
# plt.plot(airline_avg_delay_dep, color="red")
# plt.plot(airline_avg_delay_arr, color = "blue")
# plt.xlabel("Airline")
# plt.ylabel("Average delay")
# plt.legend()

# #plt.subplot(1,2,2)
# # plt.plot(airline_avg_delay_arr, color = "red")
# # plt.xlabel("Airline")
# # plt.ylabel("Average delay in arrival")

# plt.show()

airline_total = required_data.groupby("AIRLINE")["AIRLINE"].count()
airline_total

# method to get whether the flight was schedules in the morning/noon/evening/night
def groupByDepartureTime(depTime):
    if depTime.hour >=0 and depTime.hour < 6:
        return "Early Morning"
    elif depTime.hour >= 6 and depTime.hour < 12:
        return "Morning till noon"
    elif depTime.hour >= 12 and depTime.hour < 18:
        return "Afternoon till evening"
    elif depTime.hour >= 18 and depTime.hour <= 24:
        return "Night"

#grouping the flights based on the time of departure
required_data['TIME_GROUP'] = required_data['SCHEDULED_DEPARTURE'].apply(groupByDepartureTime)

#plot to get departure delay with time of flight
flight_dep_time_group = required_data.groupby(['TIME_GROUP'])['DEPARTURE_DELAY'].mean()

figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.plot(flight_dep_time_group, color = "red")
plt.xlabel("Scheduled Departure Time")
plt.ylabel("Average delay in departure")

plt.show()

# method to get whether the airtime of the flight
def groupByFlightTime(fltTime):
    if fltTime >=0 and fltTime <= 90:
        return "< 1.5 hours"
    elif fltTime > 90 and fltTime <= 240:
        return "< 4 hours"
    elif fltTime > 240 and fltTime <= 480:
        return "< 8 hours"
    elif fltTime > 480:
        return "> 8 hours"

#grouping the flights based on the airtime
required_data['AIR_TIME'] = required_data['SCHEDULED_TIME'].apply(groupByFlightTime)

#plot to get departure delay with airtime
flight_dep_air_time = required_data.groupby(['AIR_TIME'])['DEPARTURE_DELAY'].mean()

figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.plot(flight_dep_air_time, color = "red")
plt.xlabel("Scheduled Air time")
plt.ylabel("Average delay in departure")

plt.show()

#grouping departure time by origin of airport and taking the ones with max 20 delays
airport_avg_delay = required_data.groupby(['ORIGIN_AIRPORT'])['DEPARTURE_DELAY'].mean().sort_values().tail(10)

#plot of departure delay with origin airport - taking airports with max 10 delay time
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.plot(airport_avg_delay, color = "red")
plt.xlabel("Origin Airport")
plt.ylabel("Average delay in departure")
plt.show()

required_data

figure(num=None, figsize=(12, 10), dpi=80, facecolor='w', edgecolor='k')
# Pie chart
labels = ['Early', 'On time', 'Minor Delay', 'Major Delay', 'Canceled']
sizes = [early, on_time, minor_delay, major_delay, cancelled]
#colors
colors = ['#ff9999','#66b3ff','#99ff99','#ffcc99', '#dfff99']
#explsion
explode = (0.1,0.1,0.1,0.1,0.1)
fig1, ax1 = plt.subplots()
plt.pie(sizes, colors = colors, labels=labels, autopct='%1.1f%%', startangle=180, pctdistance=0.85, explode = explode)
#draw circle
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)
# Equal aspect ratio ensures that pie is drawn as a circle
#ax1.pie(sizes, colors = colors, labels=labels, autopct='%1.1f%%', startangle=90)
ax1.axis('equal')  
plt.tight_layout()
plt.show()

#taking in consideration the data for which delay is less than 2.5 hours
#delay more than 2.5 hours is most probably because of some technical failure or weather conditions
required_data = required_data[required_data['DEPARTURE_DELAY'] <= 150]

required_data.columns

label_encoder = LabelEncoder()
required_data['AIR_TIME'] = label_encoder.fit_transform(required_data['AIR_TIME'])
required_data['TIME_GROUP'] = label_encoder.fit_transform(required_data['TIME_GROUP'])
required_data['AIRLINE'] = label_encoder.fit_transform(required_data['AIRLINE'])
required_data['ORIGIN_AIRPORT'] = label_encoder.fit_transform(required_data['ORIGIN_AIRPORT'])
required_data['DESTINATION_AIRPORT'] = label_encoder.fit_transform(required_data['DESTINATION_AIRPORT'])

new_x_data = required_data.iloc[:,[0,1,2,6,11]]
new_y_data = required_data.iloc[:,[5]]

one_hot_encoder = OneHotEncoder()
new_x_data = one_hot_encoder.fit_transform(new_x_data).toarray()
new_x_data

# Split the data into training and testing sets
train_features, test_features, train_labels, test_labels = train_test_split(new_x_data, new_y_data, test_size = 0.25, random_state = 7)

model = LinearRegression()
model.fit(train_features, train_labels)

predicted_values = model.predict(test_features)

predicted_values.shape

residuals = np.subtract(predicted_values, test_labels)

print('Mean Squared Error for Linear Regression is:', np.mean(np.square(residuals)))

correctClassifications = comparePredictedAndActualValues(predicted_values, test_labels)
correctClassifications/predicted_values.shape[0]
#n = predicted_values_lr[0,0] - test_labels[0,0]
#test_labels.iloc[0,0]

# Instantiate model with 1000 decision trees
rf = RandomForestRegressor(n_estimators = 30, random_state = 7)
# Train the model on training data
rf.fit(train_features, train_labels);

predicted_values_rf = rf.predict(test_features)

predicted_values_rf = predicted_values_rf.reshape(predicted_values_rf.shape[0],1)

errors_rf = np.subtract(predicted_values_rf, test_labels)

print('Mean Squared Error for Random Forest is:', np.mean(np.square(errors_rf)))



correctClassifications = comparePredictedAndActualValues(predicted_values_rf, test_labels)
correctClassifications/predicted_values.shape[0]
#n = predicted_values_lr[0,0] - test_labels[0,0]
#test_labels.iloc[0,0]

logistic = LogisticRegression(random_state=7)
logistic.fit(train_features, train_labels)

predicted_values_lr = logistic.predict(test_features)

predicted_values_lr = predicted_values_lr.reshape(predicted_values_lr.shape[0],1)

errors_lr = np.subtract(predicted_values_lr, test_labels)

print('Mean Squared Error for Logistic Regression is:', np.mean(np.square(errors)))

correctClassifications = comparePredictedAndActualValues(predicted_values_lr, test_labels)
correctClassifications/predicted_values_lr.shape[0]
#n = predicted_values_lr[0,0] - test_labels[0,0]
#test_labels.iloc[0,0]

def comparePredictedAndActualValues(pred,act):
    count = 0
    for i in range(act.shape[0]):
        if abs(pred[i,0] - act.iloc[i,0]) <= 5:
            count = count+1
    return count

predicted_values.shape

early = required_data_1[required_data_1.DEPARTURE_DELAY <= -5].shape[0]
cancelled = required_data_1[required_data_1.CANCELLED==1].shape[0]
major_delay = required_data_1[required_data_1.DEPARTURE_DELAY >= 30].shape[0]
on_time = required_data_1[required_data_1.DEPARTURE_DELAY > -5].shape[0] - required_data_1[required_data_1.DEPARTURE_DELAY > 5].shape[0]
minor_delay = required_data_1[required_data_1.DEPARTURE_DELAY > 5].shape[0] - required_data_1[required_data_1.DEPARTURE_DELAY >= 30].shape[0]

